# 概述

本篇文章主要分为两部分。第一部分讲解多线程编程的基础知识。第二部分讲解C++11中多线程编程的知识。  

# 第一部分 多线程编程基础知识

## 进程与线程的区别

## 并发与并行

## 可重入性与线程安全

## 线程间通信

## joinable 与 detach

## 内核线程与用户线程（微信收藏）


# 第二部分 C++11多线程编程

## C++多线程编程概述

C++11中关于线程的内容增加了不少，号称已经做到了平台无关。本文第二部分主要翻译了cppreference.com上的关于多线程编程的主要文档。
总结一下，关于C++11中的thread的内容可分类如下：  

	Thread support Library:  

	    Threads：  
	        thread  
	
	    this_thread namespace:  
	        get_id  
	        yield  
	        sleep_for   
	        sleep_until  
	
	    Mutual exclusion:  
	        mutex, timed_mutex, recursive_mutex, recusive_timed_mutex  
	        shared_mutex(C++17), shared_timed_mutex(C++14)  
	        
	    Generic mutex management:  
	        lock_guard, unique_lock, shared_lock(C++14),    
	        [defer_lock_t, try_to_lock_t, adopt_lock_t],  
	        [defer_lock, try_to_lock, adopt_lock],   
	        
	    Generic locking algorithms:  
	        try_lock, lock  
	        
	    Call once:  
	        once_flag, call_once  
	         
	    Condition variables:  
	        condition_variable, condition_variable_any,   
	        notify_all_at_thread_exit, cv_status  
	        
	    Futures:  
	        promise, packaged_task, future, shared_future, async,  
	        launch, future_status,   
	        
	    Future errors:  
	        future_error, future_category, future_errc  


         
# 第一章 std::thread (参见《译文_C++11多线程之std_thread》，以下为增加)

## 成员类型

成员类型                定义
native_handle_type  implementation-defined

## 成员类

### std::thread::id (参见《译文_C++11多线程之std_thread_id》)

## 成员函数  

### 构造函数
  
thread();                                           (1) (since C++11)   
// 创建一个线程对象，但并不代表一个线程

thread( thread&& other );                           (2) (since C++11)   
// Move构造函数，构建一个线程对象来代表线程other的运行，在此次调用结束后，other将不代表一个线程的运行

template< class Function, class... Args > 
explicit thread( Function&& f, Args&&... args );    (3) (since C++11)
// 创建一个线程对象，并将其和一个线程的执行关联起来。新线程开始执行。

thread(const thread&) = delete;                     (4) (since C++11)
// 拷贝构造函数是被禁止的，线程是不能被拷贝的。不会有2个线程对象来代表同一个线程的执行。

### 析构函数  

如果 *this 拥有一个相关联的线程（其joinable() == true），那么std::terminate()就会被调用。  

注意：  
以下4种情况下，一个线程对象不会拥有一个相关联的线程（即可以安全地销毁）：
- 该线程对象是默认构造的
- 该线程对象已经是作为move的源端了
- join()函数已经被调用
- detach() 函数已经被调用

### operator = 
thread& operator=(thread&& other);    (since C++11)

如果 *this 仍然拥有一个相关联的正在运行的线程（即，joinable() == ture），那么std::terminate()会被调用。否则，将other的状态赋给 *this，并将other给设置到默认构造的状态。

### joinable  
bool joinable() const;      (since C++11)
检查该线程对象是否代表一个活动的线程的运行。具体来说，如果 get_id() != std::thread::id()，那么就返回 true. (笔者注： std::thread::id()是显式调用一个构造函数，其返回值是一个线程id，但因为此线程并没有真正运行，所以该id是一个特殊值；所以，如果get_id()返回的值与此特殊值相同，则说明那并不是一个真正的运行的线程，而如果不同，则说明get_id()的主体线程是一个正在运行的线程。) 所以一个默认构造的thread对象不是joinable的。
一个已经完成了执行的线程，但还没有被join，那它仍然算作是一个活动的线程的运行，因此是joinable的。  
参见程序"01_std_thread_joinable.cpp". 

### get_id
std::thread::id get_id() const;     (since C++11)
返回和 *this 相关联的一个线程的std::thread::id的值。
参见程序"01_std_thread_get_id.cpp". 

### native_handle
native_handle_type native_handle(); (since C++11)
返回线程处理的底层实现（Returns the implementation defined underlying thread handle）。
参见程序"01_std_thread_native_handler.cpp".

### join
void join();    (since C++11)
阻塞当前线程，直到*this线程（译注：即join()的拥有者线程）完成它的执行。
参见程序"01_std_thread_join.cpp". 

### detach
void detach();  (since C++11)
将线程的执行与线程对象分离开来，使得线程的执行可以无依赖地继续。一旦线程退出，任何所分配的资源都会被释放。
在调用detach()之后，*this 就不再拥有任何线程了。
参见程序"01_std_thread_detach.cpp". 

### swap
void swap( thread& other );     (since C++11)
交换两个线程对象的底层处理（underlying handle）。
参见程序"01_std_thread_swap.cpp". 

## 非成员函数

### std::swap
void swap( thread &lhs, thread &rhs );      (since C++11)
为std::thread重载了std::swap. 交换lhs和rhs的状态。调用lhs.swap(rhs)更加高效。
参见程序"01_std_swap.cpp". 

  

# 第二章 std::this_thread

## std::this_thread::get_id
参见程序"02_std_this_thread_get_id.cpp"

## std::this_thread::sleep_for
参见程序"02_std_this_thread_sleep_for.cpp"

## std::this_thread::yield
参见程序"02_std_this_thread_yield.cpp"

  

# 第三章 mutex

## 3.1 std::mutex

### 成员函数

#### 构造函数

constexpr mutex();      (1) (since C++11)
构造之后，是处于unlocked状态的。

mutex( const mutex& ) = delete;     (2) (since C++11)
拷贝构造函数是禁止的。

#### 析构函数
~mutex();
销毁mutex. 如果某线程持有mutex的所有权时，该线程terminate了，那么程序的行为是未定义的。

#### operator = [deleted]
拷贝赋值操作符是被禁止的。

#### lock
void lock();    (since C++11)
锁住mutex. 如果另一个线程已经lock了这个mutex，那么当前的lock调用就会阻塞执行，直到获得mutex. 
如果在线程已经拥有mutex的时候，再进行lock，那么程序的行为是未定义的：程序可能会死锁，或者，如果实现能够检测到死锁，一个叫做resource_deadlock_would_occur的error condition将会被抛出。

注意：
一般来说，lock()是不会被直接调用的。std::unique_lock和std::lock_guard才是被用来管理互斥锁的。

参见程序"03_std_mutex_lock.cpp"

#### try_lock
bool try_lock();    (since C++11)

试图锁住mutex. 立即返回： 一旦lock成功，就返回true；否则，返回false. 
本函数允许假性失败而返回false，即，在某些情况下mutex并没有被其他线程锁住也可能会返回false.
如果一个线程已经拥有了mutex，再去调用try_lock,那么程序行为是未定义的。

参见程序"03_std_mutex_try_lock.cpp"

#### unlock
void unlock();  (since C++11)
释放mutex. 

关于std::mutex, 参见示例程序"03_std_mutex.cpp"


## 3.2 std::timed_mutex

std::timed_mutex
定义在头文件 <mutex> 中
class timed_mutex；  (since C++11)

和mutex一样，timed_mutex是一个同步原语，用来保护共享数据被多线程同时访问。
和mutex类似的是，timed_mutex提供互斥的、非递归的所有权语义。另外，timed_mutex通过try_lock_for()和try_lock_until()提供一种声明：在一定的时间段内对一个timed_mutex的所有权。

### 成员函数

#### 构造函数

timed_mutex();   (1) (since C++11)
构造此timed_mutex. 在此调用之后，此timed_mutex是处于unlocked状态的。

timed_mutex(const timed_mutex&) = delete;   (2) (since C++11)
拷贝构造函数是被禁止的。

#### 析构函数
~timed_mutex();
销毁此timed_mutex. 若某线程拥有此timed_mutex时结束了（terminate），那么程序的行为是未定义的。

#### operator=[deleted]
拷贝赋值操作符是被禁止的。

#### lock
void lock();    // 和std::mutex的lock()类似

#### try_lock
bool try_lock();    //  和std::mutex的try_lock()类似

#### try_lock_for
template<class Rep, class Period>
bool try_lock_for(const std::chrono::duration<Rep, Period>& timeout_duration);  (since C++11)

试图锁住timed_mutex. 一直阻塞到timeout_duration已经超时或者得到lock. 成功获得锁，返回true；否则返回false. 
如果timeout_duration比timeout_duration.zero()少或者相等，那么此函数的行为就和try_lock()类似。

如果一个线程已经拥有了这个timed_mutex,此时该线程再去调用try_lock_for,那么行为是未定义的。
参见程序"03_02_std_timed_mutex_try_lock_for.cpp"

#### try_lock_until
template< class Clock, class Duration >
bool try_lock_until( const std::chrono::time_point<Clock,Duration>& timeout_time );     (since C++11)

试图锁住timed_mutex. 一直阻塞到timeout_time时间点到来或者得到lock. 成功获得锁，返回true；否则返回false. 
其他与try_lock_for类似。
参见程序"03_02_std_timed_mutex_try_lock_until.cpp"

#### unlock
void unlock();    (since C++11)
必须是释放自己拥有的mutex，否则行为未定义。


## 3.3 std::recursive_mutex

定义在头文件 <mutex> 中。
class recursive_mutex;   (since C++11)

recursive_mutex是一个同步原语，用来保护被多个线程同时访问的共享数据。
recursive_mutex提供互斥的、递归的所有权语义：
- 调用者线程拥有recursive_mutex一段时间，这段时间始自第一次成功调用lock()或try_lock(). 在这段时间内，该线程可以多次调用lock()或try_lock().这段时间的结束点是当调用了相同次数的unlock()时。
- 当一个线程拥有一个recursive_mutex时，所有其他的线程都阻塞住（调用了lock）或收到false返回值（调用了try_lock）。 
- 一个recursive_mutex可以被lock的最大次数是不一定的，但是当达到此限制时，在调用lock, std::system_error就会被抛出；而再调try_lock，就会返回false. 

如果一个线程正拥有着一个recursive_mutex(译注：尚未达到相同次数的unlock调用)，此时该recursive_mutex被销毁了，那么程序行为是未定义的。

### 成员函数

构造函数：
recursive_mutex();  // 构造该mutex. 此调用后，该mutex处于unlocked状态。
recursive_mutex(const recursive_mutex&) = delete;   // Copy构造函数被禁止。

析构函数：
~recursive_mutex();  // 若正拥有着一个recursive_mutex时，拥有者线程被结束，程序行为未定义。

operator=[deleted]  // 拷贝赋值操作符被禁止。

void lock();
bool try_lock();
void unlock();


## 3.4 std::recursive_timed_mutex

融合了std::recursive_mutex和std::timed_mutex的特点。

recursive_timed_mutex();
recursive_timed_mutex(const recursive_timed_mutex &) = delete;
~recursive_timed_mutex();
operator=[deleted]

void lock();
bool try_lock();

template< class Rep, class Period >
bool try_lock_for( const std::chrono::duration<Rep,Period>& timeout_duration );

template< class Clock, class Duration >
bool try_lock_until( const std::chrono::time_point<Clock,Duration>& timeout_time );


# 第四章 lock

## 4.1 std::lock_guard

定义在头文件 <mutex> 中。

template <class Mutex>      (since C++11, until C++17)
class lock_guard;

template <class... MutexTypes>  (since C++11, until C++17)
class lock_guard;

lock_guard 类是一个mutex封装者，它为了拥有一个或多个mutex而提供了一种方便的 RAII style 机制。（**译注：所谓的RAII，全称为Resource Acquisition Is Initialization，汉语是“资源获取即初始化”。但是这个直译并没有很好地解释这个词组的含义。其实含义并不高深复杂，简单说来就是，在资源获取的时候将其封装在某类的object中，利用"栈资源会在相应object的生命周期结束时自动销毁"来自动释放资源，即，将资源释放写在析构函数中。所以这个RAII其实就是和智能指针的实现是类似的。**）

当一个lock_guard对象被创建后，它就会尝试去获得给到它的mutex的所有权。当控制权不在该lock_guard对象所被创建的那个范围后，该lock_guard就会被析构，从而mutex被释放。
如果给定几个mutex，那么死锁避免算法就会被使用，比如 std::lock. (自从C++17)

lock_guard类是 non-copyable的。


### 模板参数

Mutex - mutex的类型。此类型必须符合 BasicLockable 的要求。
MutexTypes - 各种mutex的类型，即，此处可以填写多个mutex. 这些类型必须符合 Lockable 的要求，除非只有一个mutex，若是只有一个，则只需满足 BasicLockable 的要求。 

### 成员函数

构造函数:  
构造一个lock_guard，选择性地锁住给定的mutex. 

析构函数: 
析构lock_guard, 解锁底层的mutex. 

operator= [deleted]:  
not copy-assignable


## 4.2 std::unique_lock  

定义在头文件 <mutex> 中。

template <class Mutex>      (since C++11)
class unique_lock;

类 unique_lock 是一个一般性质的 mutex 属主的封装，提供延迟锁定（deferred locking），限时尝试（time-constrained attempts），递归锁定（recursive locking）， 锁主的转换， 以及对条件变量的使用。  

类 unique_lock 是 movable 的，但不是 copyable 的 -- 它满足 MoveConstructible 和 MoveAssignable, 但不满足 CopyConstructible 和 CopyAssignable.  

类 unique_lock 满足 BasicLockable 的要求。如果 Mutex 满足 Lockable 的要求，那么 unique_lock 也满足 Lockable 的要求（比如，可以被用于 std::lock）；如果 Mutex 满足 TimedLockable 的要求，unique_lock 也满足 TimedLockable 的要求。

### 模板参数  

Mutex - 用于锁定的 mutex 的类型。该类型必须满足 BasicLockable 的要求。  

### 构造函数  

(1) unique_lock();  
(2) unique_lock( unique_lock&& other );  
(3) explicit unique_lock( mutex_type& m );
(4) unique_lock( mutex_type& m, std::defer_lock_t t );
(5) unique_lock( mutex_type& m, std::try_to_lock_t t );
(6) unique_lock( mutex_type& m, std::adopt_lock_t t );
(7) template< class Rep, class Period >
    unique_lock(mutex_type& m, 
                const std::chrono::duration<Rep,Period>& timeout_duration);
(8) template< class Clock, class Duration >
    unique_lock(mutex_type& m, 
                const std::chrono::time_point<Clock,Duration>& timeout_time);

(1) unique_lock();  
    构造一个没有关联 mutex 的 unique_lock  
    
(2) unique_lock( unique_lock&& other );  
    Move构造函数，使用 other 的内容来构造 unique_lock. 使得other变成没有mutex关联的unique_lock.  

(3) - (8) 构造一个以 m 为关联的mutex的unique_lock, 另外： 
    
(3) explicit unique_lock( mutex_type& m );  
    通过调用 m.lock() 来锁定相关联的 mutex. 如果当前线程已经拥有了mutex，且不是递归的mutex，那么行为未定义。

(4) unique_lock( mutex_type& m, std::defer_lock_t t );  
    不锁定相关的mutex. 

(5) unique_lock( mutex_type& m, std::try_to_lock_t t );
    通过调用 m.try_lock() 来尝试锁定相关的mutex而不会阻塞。如果当前线程已经拥有mutex且不是递归mutex，则行为未定义。
    
(6) unique_lock( mutex_type& m, std::adopt_lock_t t );  
    假设线程已经拥有m. 

(7) template< class Rep, class Period >  
    unique_lock(mutex_type& m, const std::chrono::duration<Rep,Period>& timeout_duration);  
    通过调用 m.try_lock_for(timeout_duration) 试图锁定相关联的 mutex. 一直阻塞直到超时或锁定成功。也可能阻塞得比time_duration的时间更长一些。
    
(8) template< class Clock, class Duration >  
    unique_lock(mutex_type& m, const std::chrono::time_point<Clock,Duration>& timeout_time);  
    通过调用 m.try_lock_until(timeout_time) 来试图锁定相关联的 mutex. 一直阻塞直到指定的时间点到达或者锁定成功。可能会在指定的时间到达后仍阻塞一会儿。

### 析构函数  

销毁这个unique_lock对象。如果 *this 此时拥有一个相关联的 mutex 并且已经获得它，那么就会解锁该mutex.  

### 赋值操作符 operator =

unique_lock& operator=( unique_lock&& other );    (since C++11)  

Move赋值操作符。使用 other 中的内容来赋值给自己。  
如果在此调用前，*this 已经拥有一个mutex并锁定了它，那么此调用会解锁该mutex.  

### std::unique_lock::lock 函数

void lock();    (since C++11)
锁定关联的mutex. 高效地调用 mutex()->lock(). 

异常：
- 抛出mutex()->lock()所抛出的异常。  
- 如果没有相关联的 mutex, std::system_error就会抛出，所携带的错误码是std::errc::operation_not_permitted.  
- 如果mutex已经被本unique_lock锁定了（换句话说，owns_lock为true），那么std::system_error就会被抛出，错误码是std::errc::resource_deadlock_would_occur.  

参见示例程序： 04_02_std_unique_lock_lock.cpp  

### std::unique_lock::try_lock 函数  

bool try_lock();    (since C++11)
试图锁定相关联的mutex，而不会阻塞。高效地调用 mutex()->try_lock().  
如果没有相关联的mutex或者该mutex已经被该unique_lock锁定，那么 std::system_error 就会被抛出。  

异常：  
- 任何 mutex()->try_lock() 抛出的异常都会被抛出 （Mutex类型不会被try_lock抛出，但一个自定义的Lockable类型可能会被抛出）。  
- 如果没有相关联的mutex，那么std::system_error就会被抛出，其错误码是std::errc::operation_not_permitted.  
- 如果mutex已经被本unique_lock锁定了，std::system_error也会被抛出，错误码是std::errc::resource_deadlock_would_occur.  

### std::unique_lock::try_lock_for 函数  

template<class Rep, class Period>  
bool try_lock_for( const std::chrono::duration<Rep, Period>& timeout_duration );  (since C++11)  

试图锁定相关联的mutex. 会阻塞住，直到指定的时间段超时或者锁定成功。一旦成功锁定，就返回true，否则返回false. 高效地调用 mutex()->try_lock_for(timeout_duration).  
一个稳定的时钟被用来衡量此时间段。本函数可能阻塞地比timeout_duration的时间更久一些，原因是系统调度或资源竞争所导致的延时。  
如果没有相关联的mutex或该mutex已经被锁定，则std::system_error就会被抛出。  

返回值：  
获得mutex则返回true，否则false.  

异常:  
- 任何被mutex()->try_lock_for(timeout_duration)抛出的异常都将被抛出；  
- 若没有相关联的mutex，则std::system_error就会被抛出，错误码是std::errc::operation_not_permitted;  
- 若mutex已经被锁的那个，则std::system_error就会被抛出，错误码是std::errc::resource_deadlock_would_occur.  

### std::unique_lock::unlock 函数  

void unlock();    (since C++11)  
解锁相关的mutex.  
如果没有相关联的mutex或该mutex已经被锁定，则std::system_error就会被抛出。   

异常：  
- 任何被mutex()->unlock()抛出的异常都会被抛出。  
- 如果没有相关联的mutex或者mutex并没有被锁定，则std::system_error就会被抛出，错误码是std::errc::operation_not_permitted.  

### std::unique_lock::mutex 函数  

mutex_type* mutex() const;      (since C++11)
返回一个指向所关联的mutex的指针，或者如果没有相关联的mutex的话就返回一个空指针。  

### std::unique_lock::owns_lock 函数  

bool owns_lock() const;    (since C++11)  
检查 *this 是否已经锁住mutex.  
是，则返回true；否则返回false. 

### std::unique_lock::operator bool 函数  

explicit operator bool() const;    (since C++11)  

检查 *this 是否已锁定一个mutex. 高效地调用owns_lock().  
是，则返回true；否则返回false.  

### 示例程序  
04_02_std_unique_lock_all.cpp


## 4.3 lock types: std::defer_lock_t, std::try_to_lock_t, std::adopt_lock_t  

定义在头文件 <mutex> 中。
- struct defer_lock_t {};     (since C++11)  
- struct try_to_lock_t {};    (since C++11)  
- struct adopt_lock_t {};     (since C++11)  

std::defer_lock_t, std::try_to_lock_t, std::adopt_lock_t 是空的结构体，用来起到一个标记的作用，可以被用于 std::lock_guard, std::unique_lock, 和 std::shared_lock(C++14). 

类型                实例             效果
defer_lock_t        defer_lock      不会立即获得mutex的所有权  
try_to_lock_t       try_to_lock     尝试获得mutex的所有权，而不会阻塞  
adopt_lock_t        adopt_lock      假设调用者线程已经获得mutex的所有权  
    
示例程序： 04_03_std_adopt_lock_t.cpp


## 4.4 通用locking算法  

### 4.4.1 std::try_lock

定义在头文件 <mutex> 中。
template< class Lockable1, class Lockable2, class... LockableN>  
int try_lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn )；    (since C++11)  

通过调用 try_lock 按顺序一个一个地来锁定给定的Lockable对象 lock1, lock2, ..., lockn.  
如果有一个 try_lock 失败了，所有被锁住的对象都会被解锁，并且失败的那个对象的index（0-based）会被返回。  
如果一个 try_lock 的调用导致了异常，在抛出异常之前，所有锁住的对象都会被解锁。  

返回值： 
返回-1,表示成功锁定所有对象；
返回0-based的index代表试图锁定但失败的那个对象的index. 

示例程序： 04_04_std_try_lock.cpp  


### 4.4.2 std::lock

定义在头文件 <mutex> 中。
template< class Lockable1, class Lockable2, class... LockableN >  
void lock( Lockable1& lock1, Lockable2& lock2, LockableN&... lockn );   (since C++11)  

使用一种死锁避免算法来锁住给定的Lockable对象 lock1, lock2, ..., lockn 以避免死锁。  
以一种不确定的调用顺序来调用lock, try_lock, unlock，以锁定lock1，lock2，...，lockn. 如果一个lock或unlock导致了异常，在抛出此异常前，所有被锁住的对象都会被解锁。  

示例程序： 04_04_std_lock.cpp  

## 4.5 Call Once  

### 4.5.1 std::once_flag  

定义在头文件 <mutex> 中。
class once_flag;    (since C++11)  

类 std::once_flag 是一个辅助std::call_once的结构体。  
一个std::once_flag类型的实例被传递给多个std::call_once的调用，这会使得这些调用相互协调，进而最后只有一个调用能完成运行。  
std::once_flag既不是copyable的，也不是movable的。  

成员函数： 
constexpr std::once_flag::once_flag();  

构造一个once_flag对象。内部状态被设置为还没有函数被调用。


### 4.5.2 std::call_once  

定义在头文件 <mutex> 中。  
template< class Callable, class... Args >   
void call_once( std::once_flag& flag, Callable&& f, Args&&... args );   (since C++11)  

即使有多个线程，也仅仅只执行该Callable对象一次。  
接收同一个std::once_flag对象的每组call_once调用都要符合下列的要求：  
- 只有一个函数的一次执行会被执行。至于是哪个函数，则是未定义的。被选中的函数和它所传进的call_once调用，这二者是在同一个线程中。 
- 在被选中函数的执行成功完成之前，该组中没有调用返回。即，不会通过一个异常而退出。  
- 如果选中的函数通过异常退出了，该函数会被传递给调用者。从而，另一个函数会被选中和执行。  

异常：  
- 如果任何条件阻止call_once被调用，std::system_error就会抛出。  
- f（Callable的对象）所抛出的任何异常也会被抛出。  

注意：  
- (until C++17) 传递给Callable对象的参数是通过值来move或拷贝的。如果一个引用参数需要被传递给Callable对象，那么需要使用std::ref或std::cref来包装一下它。  
- (since C++17) 传递给Callable对象的参数会被完美转发的（正如std::forward<Callable>(f) 和 std::forward<Args>(args)等）， 这和在线程构造函数或std::async中使用Callable-s不同，因为call_once并非必须将它的参数传递给另一个线程来执行，因此没有必要来使用move或拷贝。  

即使是被多线程调用，函数内部的静态变量的初始化也保证仅仅只有一次。这可能比使用std::call_once来实现此功能更加高效。  

示例程序： 04_05_std_call_once.cpp  


# 第五章 std::condition_variable  

条件变量是一个同步原语，它允许多个线程之间的通信。它使得多个线程能够等待另一个线程的通知，以便于继续自己的工作。一个条件变量总是和一个mutex一起使用的。  
定义在头文件 <condition_variable> 中。  

## 5.1 std::condition_variable  

定义在头文件 <condition_variable> 中。  
class condition_variable;    (since C++11)  

condition_variable类是一个同步原语，恩你个狗同时阻塞一个或多个线程，直到另一个线程改变了一个共享变量（即条件），并通知condition_variable.  
试图改变条件变量的线程必须：  
1. 获得一个std::mutex(一般是通过std::lock_guard)  
2. 当持有锁的时候，执行对条件变量的改变  
3. 对std::condition_variable执行notify_one或notify_all(当做notify动作时，不必持有锁)

即使共享变量是原子性的，它也必须在mutex的保护下被修改，这是为了能够将改动正确发布到正在等待的线程。

任意要等待std::condition_variable的线程必须：
1. 获取std::unique_lock<std::mutex>，这个mutex正是用来保护共享变量（即“条件”）的
2. 执行wait, wait_for或者wait_until. 这些等待动作原子性地释放mutex，并使得线程的执行暂停
3. 当获得条件变量的通知，或者超时，或者一个虚假的唤醒，那么线程就会被唤醒，并且获得mutex. 然后线程应该检查条件是否成立，如果是虚假唤醒，就继续等待。
【译注： 所谓虚假唤醒，就是因为某种未知的罕见的原因，线程被从等待状态唤醒了，但其实共享变量（即条件）并未变为true。因此此时应继续等待】

std::condition_variable只能和std::unique_lock<std::mutex>一起工作；这个限制使得在某些平台上能够获得最大效率。std::condition_variable_any提供了一种能够和BasicLockable的对象一起工作的条件变量。

【译注：BasicLockable指的是为实现互斥而所需的最小特性集，即符合BasicLockable的类型，其对象必须至少要能有lock()和unlock()的能力。】

【译注：std::condition_variable_any是对std::condition_variable类的泛化。std::condition_variable只能和std::unique_lock<std::mutex>一起工作，而std::condition_variable_any则可以和只要是满足BasicLockable的用户自定义的lock类一起工作。】

条件变量允许同时调用wait, wait_for, wait_until, notify_one和notify_all这些成员函数。
std::condtion_variable类是StandardLayoutType. 它不是CopyConstructible,MoveConstructible, CopyAssignable, MoveAssignable的。

### 构造函数  

condition_variable();   (1)  (since C++11)  
condition_variable(const condition_variable&) = delete; (2)  (since C++11)  

1) 构造一个 std::condition_variable 类型的对象  
2) 拷贝构造函数是禁用的  

异常：  
如果线程没有权限创建一个条件变量，那么可能抛出一个std::system_error, 其错误码是值为std::errc::operation_not_permitted的std::error_condition；  
如果由于内存资源限制导致初始化失败，std::error_condition的值就是std::errc::resource_unavailable_try_again.  

### 析构函数  

只有所有线程都被通知到的时候调用析构函数才是安全的。并不需要线程们都退出它们相应的wait函数：一些线程可能仍然在等待以求重新获取相关的锁，或者可能已经获得锁而正在等待被安排运行。  
当析构函数已经开始执行时，编程者必须确保没有线程会尝试在 *this 上进行等待，尤其是当等待的线程正在一个循环(loop)中调用等待函数，或者使用携带谓词的重载的等待函数。  

### operator =  
赋值操作符禁用。  

### std::condition_variable::notify_one()  

void notify_one();      (since C++11)  
如果任何线程在等待 *this, 调用 notify_one 将解除其中一个线程的阻塞状态。  

示例程序： 05_01_std_condtion_variable_notify_one.cpp  

### std::condition_variable::notify_all()  

void notify_all();      (since C++11)  
解锁所有正在等待 *this 的线程。  

示例程序： 05_02_std_condtion_variable_notify_all.cpp  

### std::condition_variable::wait()  

void wait( std::unique_lock<std::mutex>& lock );    (1) (since C++11)  

template< class Predicate >
void wait( std::unique_lock<std::mutex>& lock, Predicate pred );    (2) (since C++11)  

wait 使得当前线程阻塞，直到条件变量被通知改变或者一个虚假唤醒发生，选择性地循环直到某个谓词被满足（optionally looping until some predicate is satisfied）。  

1) 
void wait( std::unique_lock<std::mutex>& lock );  
自动解锁，阻塞当前执行线程，并将其添加到等待 *this 的线程列表中。当notify_all()或notify_one()被执行时，该线程才会解除阻塞。但也可能虚假地被解除阻塞，当被解除阻塞后，无论原因，lock都会被重新获得，然后退出等待。如果本函数由于异常退出，lock也会被重新获取。（until C++14）

2) 
template< class Predicate >
void wait( std::unique_lock<std::mutex>& lock, Predicate pred );
等同于  
```{cpp}
while (!pred()) {
    wait(lock);
}
```
这个重载函数可以用于忽略虚假唤醒，因为一直等待一个特定条件变成true. 注意，在进入该方法之前，必须获得锁(lock)，在wait(lock)退出之后，也要获得锁。即，lock可以被看成是对pred()访问的保护。  

另： 
如果这些函数无法满足后验条件（即，lock.owns_lock() == ture and lock.mutex() is locked by the calling thread），std::terminate就会被调用。比如，在重新获取mutex的时候抛出一个异常，这就有可能发生上述情况。  

### std::condition_variable::wait_for()  

template< class Rep, class Period >
std::cv_status wait_for( std::unique_lock<std::mutex>& lock, const std::chrono::duration<Rep, Period>& rel_time);       (1) (since C++11)  

template< class Rep, class Period, class Predicate >
bool wait_for( std::unique_lock<std::mutex>& lock, const std::chrono::duration<Rep, Period>& rel_time, Predicate pred);  (2) (since C++11)  

返回值： 
第1种形式的wait_for函数：  如果超时，返回std::cv_status::timeout； 否则，返回std::cv_status::no_timeout.
第2种形式的wait_for函数：  如果在超时后，谓词仍然为false，那么就返回false；否则返回true.  

示例程序：  05_03_std_condtion_variable_wait_for.cpp　　

### std::condition_variable::wait_until()  

template< class Clock, class Duration >
std::cv_status wait_until( std::unique_lock<std::mutex>& lock, const std::chrono::time_point<Clock, Duration>& timeout_time );  (1) (since C++11)  

template< class Clock, class Duration, class Predicate >
bool wait_until( std::unique_lock<std::mutex>& lock, const std::chrono::time_point<Clock, Duration>& timeout_time, Predicate pred );  (2) (since C++11)  

返回值： 
第1种形式的wait_for函数：  如果超时，返回std::cv_status::timeout； 否则，返回std::cv_status::no_timeout.
第2种形式的wait_for函数：  如果在超时后，谓词仍然为false，那么就返回false；否则返回true.  

示例程序： 05_04_std_condtion_variable_wait_until.cpp  

### 本节示例程序  
05_05_std_condtion_variable.cpp  


##　5.2 std::condition_variable::any  

定义在头文件 <condition_variable> 中。
class condition_variable_any;  (since C++11)  

condition_variable_any 类是 std::condition_variable 的泛化。 鉴于 std::condition_variable 只能使用std::unique_lock<std::mutex>, condition_variable_any 可以使用任何满足 BasicLockable 要求的lock类型。  
语法部分，请参考 std::condition_variable.  
std::condition_variable_any 类是一个标准布局类 (standard-layout class)。它不是copy-constructible、move-constructible、copy-assignable、或 move-assignable 的。  
如果同为使用 std::unique_lock, std::condition_variable 会提供更好的效率。  

### 构造函数 
condition_variable_any();   (1) (since C++11)  
condition_variable_any(const condition_variable_any&) = delete;     (2) (since C++11)  

异常：  
std::system_error(带有std::error_condition == std::errc::operation_not_permitted, 或者 std::errc::resource_unavailable_try_again.)  

### 析构函数  

~condition_variable_any();      (1) (since C++11)  

销毁 std::condition_variable_any 类型的对象。  
只有在所有线程都被通知之后，调用析构函数才是安全的。并不要求所有线程退出它们的等待函数：一些线程可能仍然在等待以重新获得相关联的锁，或者在获得锁之后，等待被OS安排运行。  
一旦析构函数被调用之后，编程者必须保证没有线程会再去在 *this 上进行等待。  

### operator = [deleted]   

不是copy-assignable的。

### std::condition_variable_any::notify_one  

void notify_one();    (since C++11)  
如果有多个线程正在 *this 上进行等待，调用notify_one会解除其中一个线程的阻塞状态。  

示例代码： 05_06_std_condtion_variable_any_notify_one.cpp  

### std::condition_variable_any::notify_all  

void notify_all();      (since c++11)

示例代码： 05_07_std_condtion_variable_any_notify_all.cpp  

### std::condition_variable_any::wait

类似于 std::condition_variable::wait

### std::condition_variable_any::wait_for

类似于 std::condition_variable::wait_for

### std::condition_variable_any::wait_until

类似于 std::condition_variable::wait_until


##　5.3 std::condition_variable::any  

定义在头文件 <condition_variable> 中。 

void notify_all_at_thread_exit( std::condition_variable& cond, std::unique_lock<std::mutex> lk );  (since C++11)  

notify_all_at_thread_exit 提供一种机制： 通知其他线程，有一个线程已经完全完成了，包括销毁所有 thread_lock 的对象。它的操作包括： 
- 之前所获取的锁 lk 的所有权已经转交到内部存储中。  
- 执行环境被改变，因此当当前线程退出，条件变量 cond 就如被执行了 "lk.unlock(); cond.notify_all();" 。  
这里的  lk.unlock 位于当前线程所有本地对象销毁之后。【译注：此段文字令人费解。】  
std::promise 或 std::packaged_task 也可以造成等同的效果。  

注意：  
如果lock.mutex() 没有被锁住而调用本函数，行为是未定义的。  
如果lock.mutex() 并不是所有其他线程正在等待的那个mutex, 而调用了本函数，那么行为是未定义的。  
这里的 lock lk 会被持有，直到线程退出。一旦本函数已经被调用，没有线程可以获得相同的锁以用于等待在cond上。如果有某线程等待在这个条件变量上，在被虚假唤醒后，它不应该再试图释放并重新获得锁。【译注：此段文字有点令人费解。】
在典型的应用中，这个函数是一个detached线程所调用的最后一个函数。  

示例程序：  05_08_std_condtion_variable_notify_all_at_thread_exit.cpp (不能通过编译，因其中有些函数没有定义，完全只是示例作用)  

## 5.4 std::cv_status  

定义在头文件 <condition_variable> 中。  
enum class cv_status;    (since C++11)  

此枚举类型描述了一个限时等待的返回是否是因为超时。  
std::cv_status 被std::condition_variable和std::condition_variable_any的wait_for和wait_until方法使用。  

std::cv_status::no_timeout  条件变量被notify_all, notify_one 或 虚假唤醒 给唤醒，因此没有超时。
std::cv_status::timeout     条件变量因超时而被唤醒。  


# 第六章 Futures

标准库提供这样的功能：获得来自其他线程的返回值或从其他线程抓取异常。这些值都是以共享状态的形式实现，比如，异步的任务可以将其返回值写入共享状态，或存储一个异常到共享状态。

## 6.1 promise  

定义在头文件 <future> 中。 

template<class R> class promise;    (1) 基本模板
template<class R> class promise<R&> (2) 非void特化，用于不同线程间的对象的通信  
template<> class promise<void>;     (3) void特哈U，用于无状态时间的通信

类模板 std::promise 提供了一种能力：存储一个值或异常，而该值或异常将来是被异步地获得，而获得的方法是，通过 std::promise 对象创建 std::future 对象，再由future对象异步地提供该值或类型。 
每一个 promise 都是关联一个共享状态（shared state）的，该共享状态包含了一些状态信息和一个也许还没有被evaluate的结果（会被evaluate成一个值或者异常）。一个promise可能会对共享状态做3件事情： 
- 使准备好（make ready）： promise将值或者异常存储在共享状态中。将状态标记为ready，并且将所有等待在和该共享状态关联的future上的线程解除阻塞。  
- 释放（release）： promise放弃对共享状态的引用（reference）。如果这是最后一个这样的引用，那么这个共享状态将被销毁。除非这个共享状态是被一个尚未ready的std::async所创建的，那么这个操作将不会阻塞。
- 放弃（abandon）： promise存储错误码为std::future_errc::broken_promise的std::future_error类型的异常，并使得共享状态ready，然后释放它。  

promise是promise-future通信渠道的“推动”端： 这个操作存储一个值到共享状态。这个操作和一些成功的返回同步。这些“成功的返回”指的是从一些等待在共享状态上的函数（比如std::future::get）返回。对同一个共享状态的并发访问可能会冲突：比如，std::shared_future::get的多个调用者必须全部都是只读的或者提供额外的同步。  

### 构造函数  

1) 默认构造函数。使用一个空的共享状态来构造这个promise.  
promise();      

2) 使用一个空的共享状态来构造这个promise. 这个共享状态是被alloc给分配的。Alloc必须满足Allocator的要求。
template<class Alloc> 
promise( std::allocator_arg_t, const Alloc& alloc);  

3) Move构造函数。使用move语义，用other的共享状态来构造promise. 构造之后，other将没有共享状态。  
promise( promise&& other);  

4) promise不是copyable的。  
promise(const promise& other) = delete;  

### 析构函数  

~promise();  
放弃共享状态。  
- 如果共享状态是ready的，释放（release）它。  
- 如果共享状态是没有ready的，存储一个异常（std::future_error类型，带错误码std::future_errc::broken_promise），使共享状态为ready，然后再release它。  

### std::promise::operator=  

1) Move赋值操作符。首先，放弃共享状态（如同析构函数），然后将other的共享状态赋值过来，就如同执行了std::promise(std::move(other)).swap(*this).  
promise& operator=( promise&& other );  

2) promise不是拷贝可赋值的（not copy-assignable）。 
promise& operator( const promise& rhs ) = delete;  

### std::promise::swap  

交换2个promise对象的共享状态。  
void swap( promise& other );  

### std::promise::get_future  

std::future<T> get_future();  
返回一个future对象，该对象所关联的共享状态和*this所关联的共享状态是同一个。  

如果 *this 没有共享状态或者get_future已经被调用了，就会抛出异常。为了得到promise-future通信渠道的多个“弹出”端（pop end），要使用 std::future::shared.  

异常：  
std::future_error 在下列条件满足时被抛出：  
- *this 没有共享状态。错误分类被设置为 no_state.  
- get_future() 已经被一个拥有相同共享状态的promise调用。错误分类被设置为 future_already_retrieved.  

### std::promise::set_value  

(1) void set_value( const R& value ); 
(2) void set_value( R&& value );  
(3) void set_value( R& value );  
(4) set_value();  

原子性地将值存储到共享状态，并使得共享状态ready.  
该操作就如同set_value, set_exception, set_value_at_thread_exit, set_exception_at_thread_exit 在更新promise对象时获得了一个和该promise对象相关联的唯一mutex.  
如果没有共享状态或者共享状态已经存储了一个值或者异常，就会有异常被抛出。  

异常：  
std::future_error 在下列条件时会被抛出：  
- *this 没有共享状态。错误分类被设置为 no_state.  
- 共享状态已经存储了一个值或者异常。错误分类被设置为 promise_already_satisfied.  
另外，
(1)和(2): 任何被值的拷贝构造函数抛出的异常也会继续被抛出。    
(3): 任何被值的move构造函数抛出的异常也会继续被抛出。  

示例程序： 06_01_promise_set_value.cpp  

### std::promise::set_value_at_thread_exit   

(1) void set_value_at_thread_exit(const R& value);
(2) void set_value_at_thread_exit(R&& value);  
(3) void set_value_at_thread_exit(R& value);  
(4) void set_value_at_thread_exit();  

把值写入共享状态但并不立即使得该共享状态ready. 当该线程退出的时候，在所有thread-locak的变量都被销毁的时候，该共享状态才变为ready.  
本操作就如同当更新一个promise对象的时候，set_value, set_exception, set_value_at_thread_exit和set_exception_at_thread_exit获得了一个和该promise对象相关的mutex. (The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.)  
如果没有共享状态或者共享状态已经存储了一个值或者异常，就会有异常抛出。  

异常：  
std::future_error 会在下列条件下抛出：  
- *this 没有共享状态。错误分类将被设为no_state.  
- 共享状态已经存储了一个值或者异常。错误分类被设置为 promise_already_satisfied.  
另外：  
1-2) 值的拷贝构造函数所抛出的异常也会被抛出。
3) 值的move构造函数所抛出的异常也会被抛出。  

示例代码： 06_01_promise_set_value_at_thread_exit.cpp  

### std::promise::set_exception  

void set_exception(std::exception_ptr p);  

原子性地将异常指针p写入共享状态，并使得共享状态成为ready状态。  
本操作就如同当更新一个promise对象的时候，set_value, set_exception, set_value_at_thread_exit和set_exception_at_thread_exit获得了一个和该promise对象相关的mutex. (The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.)  
如果没有共享状态或者共享状态已经存储了一个值或者异常，就会有异常抛出。  

异常：  
std::future_error 发生在以下条件时：  
- *this 没有共享状态。错误分类将被设为no_state.  
- 共享状态已经存储了一个值或者异常。错误分类被设置为 promise_already_satisfied.  

示例程序： 06_01_promise_set_exception.cpp  

### std::promise::set_exception_at_thread_exit  

void set_exception_at_thread_exit(std::exception_ptr p);  

将异常指针p写入共享状态，但并不使得共享状态立即变为ready. 当前线程退出的时候，共享状态才变为ready,也就是在所有thread-local生命周期的变量都被销毁之后。  
本操作就如同当更新一个promise对象的时候，set_value, set_exception, set_value_at_thread_exit和set_exception_at_thread_exit获得了一个和该promise对象相关的mutex. (The operation behaves as though set_value, set_exception, set_value_at_thread_exit, and set_exception_at_thread_exit acquire a single mutex associated with the promise object while updating the promise object.)  
如果没有共享状态或者共享状态已经存储了一个值或者异常，就会有异常抛出。  

异常：  
std::future_error 发生在以下条件时：  
- *this 没有共享状态。错误分类将被设为no_state.  
- 共享状态已经存储了一个值或者异常。错误分类被设置为 promise_already_satisfied.  

### std::swap(std::promise)  

定义在头文件 <future> 中。  
template<class R>  
void swap( promise<R>& lhs, promise<R>& rhs);  
为std::promise而特化std::swap. 交换lhs和rhs的共享状态。高效地调用 lhs.swap(rhs).  

### 总示例程序 

06_01_promise.cpp  


## 6.2 std::packaged_task  

定义在头文件 <future> 中。  
(1) template< class > class packaged_task;  // not defined  
(2) 
template< class R, class ...Args >
class packaged_task<R(Args...)>;  

类模板 std::packaged_task 可以封装任何 Callable 的目标（如：函数、lambda表达式、bind expression、或其他函数对象），因此它可以被异步地调用。它的返回值或抛出的异常是被存储在共享状态（shared state）中的，而该共享状态可以通过std::future 对象被访问。  

正如std::function, std::packaged_task是一个多态的、分配敏感的容器：在其中存储的callable的目标可能被分配在堆上，或者自带一个allocator.  

### 构造函数  

1) pacakged_task();
   构造一个不带task或shared state的packaged_task对象。
   
2)  
template<class F> 
explicit packaged_task(F&& f);  

构造一个packaged_task对象，它带有一个shared state和一个task的拷贝，该拷贝以std::forward<F>(f)来初始化。This constructor does not participate in overload resolution if std::decay<F>::type is the same type as std::packaged_task<R(ArgTypes...)>.  

5) packaged_task( packaged_task&& rhs );
   构造一个packaged_task对象，它带有rhs所拥有的task和shared state，但调用后将使得rhs不具有shared state和task.  
   
示例程序： 06_02_packaged_task_constructor.cpp  

### 析构函数  
~packaged_task();  
禁止shared state并销毁所存储的task对象。  

### operator =  
略  

### valid函数
bool valid() const;  
检查 *this 是否有一个共享状态。  

### get_future函数  
std::future<R> get_future();  
返回一个future对象，它和 *this 共享同一个shared state.  
对每一个packaged_task, get_future只能被调用一次。  

异常： 
std::future_error会出现在以下的条件下： 
- 如果已经调用过了get_future，此时再调用，会出现 future_already_retrieved 错误；
- 如果 *this 没有shared state，那么错误类别是 no_state. 

### make_ready_at_thread_exit  
void make_ready_at_thread_exit( ArgTypes... args );  

使用转交的args作为参数，调用所存储的task. task的返回值或任何抛出的异常都被存储在 *this 的shared state中。  
仅仅在线程退出，并且所有的线程局部变量都被销毁后，shared state才会被变成ready.  

异常：  
std::future_error 会出现在下列的错误条件上。  
所存储的task已经被调用了。那么错误类别为 promise_already_satisfied.  
*this 没有shared state. 错误类别为 no_state.  

示例程序： 06_02_packaged_task_make_ready_at_thread_exit.cpp  

### reset 函数  

void reset();  
丢弃之前的执行，重置状态。新的shared state被构建。  
等同于 *this = packaged_task(std::move(f)), f就是task.  

示例程序： 06_02_packaged_task_reset.cpp  

### 总示例程序  
06_02_packaged_task.cpp  


## 6.3 future  

定义在头文件 <future> 中。 

1)  
template< class T > class future;  

2)  
template< class T > class future<T&>;  

3)  
template<> class future<void>;  

模板类 std::future 提供了一种机制，用以访问异步操作的结果：  
- 一个异步操作（如被 std::async, std::pacakged_task, 或std::promise所创建的）可以给异步操作的创造这提供一个 std::future 对象。  
- 异步操作的创造者然后就可以使用一些方法来query、wait for、或从std::future 中提取一个值。如果异步操作还没有提供一个值，那么这些方法可能会阻塞。  
- 但异步操作通过修改shared state（比如，std::promise::set_value）来将结果发送给创建者，而shared state是链接到std::future的。  
注意，std::future 所引用的shared state是不会和任何其他异步返回对象共享的（不同于 std::shared_future的）。  


### 6.3.1 构造函数  

1) future();
默认构造函数。构造一个 std::future 对象，但不带shared state. 构造之后，valid() == false.  

2) future(future && other);  
Move构造函数。构造一个 std::future 对象，其shared state就是使用了move语义后来自于other的shared state. 构造之后，other.valid() == false.  

3) future( const future& other ) = delete;  
std::future 不是 CopyConstructible的。  

### 6.3.2 析构函数  

~future();  
释放任何的shared state. 

### 6.3.3 operator =  

1) future& operator=( future&& other );  
用另一个future对象的内容来进行赋值。  
释放所有的shared state，并且将other的内容移动赋值给 *this. 在赋值后，other.valid() == false 并且 this->valid() 提供和other.valid()相同的值在赋值前。  

2) future& operator=( const future& other ) = delete;  
std::future 不是 CopyAssignable的。  

### 6.3.4 share 函数  

std::shared_future<T> share();  
将 *this 的shared state传递给一个 std::shared_future 对象。 多个shared_future对象可以引用同一个shared state，但这对于std::future是不可能的。  
在调用了std：：future上的share之后，valid() == false.  
如果在调用此函数之前valid() == false,那么行为是未定义的。   

### 6.3.5 get函数  

1) T get();   // future模板的成员函数   
   返回值存储在shared state中，比如 std::move(v)

2) T& get();  // future<T&> 模板特化的成员函数
   返回值是指向shared state中的值的引用。    

3) void get();  // future<void> 模板特化的成员函数   
   没有返回值。  

get方法会一直等待，直到future有一个有效的结果并且取得它。它高效地调用wait()是为了等待结果。  
泛化模板和2个模板特化都各自有一个版本的get. 这3个版本的get在返回值类型上不同。  
如果在调用此函数前valid()是false,那么行为未定义。  
在调用此函数之后，valid()就是false了。  

示例程序： 06_03_future_get.cpp  

### 6.3.6 valid 函数  

bool valid() const;  
检查future对象是否参考一个shared state.  
只有不是默认构造的或不是moved from的（为std::promise::get_future(), 或 std::packaged_task，或std::async() 所返回的），直到第一次get()或share()被调用。（This is the case only for futures that were not default-constructed or moved from (i.e. returned by std::promise::get_future(), std::packaged_task::get_future() or std::async()) until the first time get() or share() is called.）  

### 6.3.7 wait  
void wait() const;  
阻塞直到有结果。 在调用之后，valid()==true.  
如果在调用此函数之前，valid()==false，那么行为未定义。  

示例程序：  06_03_future_wait.cpp  

### 6.3.8 wait_for  

template< class Rep, class Period >  
std::future_status wait_for( const std::chrono::duration<Rep, Period>& timeout_duration ) const;  

等待结果。阻塞，直到时限到达或结果出来。返回值标识了结果的状态。  
一个steady clock被用来度量经过的时间。因为调度或资源竞争的延时，这个函数可能会阻塞比时限(timeout_duration)更长的时间。  

如果在调用此函数之前，valid()==false，那么行为未定义。  

示例程序： 06_03_future_wait_for.cpp  

### 6.3.9 wait_until  

template< class Clock, class Duration >  
std::future_status wait_until( const std::chrono::time_point<Clock, Duration>& timeout_time ) const;  

wait_until 等待直到结果出来。它会一直阻塞，直到timeout_time时间点到达或者结果出现。返回值标识wait_until返回的原因。  

如果在调用此函数之前valid()==false，那么行为未定义。  

示例程序： 06_03_future_wait_until.cpp 

### 6.3.10 示例程序  

06_03_future_wait.cpp  


## 6.4 shared_future

定义在头文件 <future> 中。  

1) template< class T > class shared_future;  
2) template< class T > class shared_future<T&>;  
3) template<> class shared_future<void>;  

类模板 std::shared_future 提供一种机制以访问异步操作的结果，类似于 std::future，但它允许多线程等待同一个shared state.  
和std::future不同，std：：future只是 movable的（所以只有一个实例能够引用到异步的结果），而std::shared_future是copyable和多个shared future对象可以指向同一个shared state的。  
如果每个线程都是通过它自己的对shared_future对象的拷贝来访问同一个 shared state，那么多线程的访问是安全的。  

### 6.4.1 构造函数

1) shared_future();  
   默认构造函数。构造一个空的shared future, 它不会指向一个shared state，即 valid() == false.  
   
2) shared_future( const shared_future& other );  
   构造一个shared future, 它和other都是指向同一个shared state的。  

3) shared_future( std::future<T>&& other );  
4) shared_future( shared_future&& other );  
3) 和 4): 构造之后， other->valid() == false, 而 valid() 的返回值和构造之前other所返回的other.valid()的返回值是相同的。

### 6.4.2 析构函数 ~shared_future()

~shared_future();  

如果 *this 是指向该shared state的最后一个对象，那么销毁这个shared state. 否则什么也不做。  

### 6.4.3 operator=

略， 同普通赋值操作符和移动复制操作符的语义。  

### 6.4.4 get函数

1) const T& get() const;  
2) T& get const;  
3) void get() const;  

get方法会等待，直到shared_future有一个有效的结果并且取得它（取决于使用了哪一个模板）。它高效地调用wait()是为了等待结果。  
通用模板和2个特化模板各自包含了get的一个版本。这3个版本在返回值上不同。  
如果在调用此函数前，valid()是false的，那么行为未定义。  

###6.4.5 valid函数 

bool valid() const;  

检查这个future对象是否指向一个shared state.  

本函数只对非默认构造的future和非移动获得的future有效。和std::future不同的是，std::shared_future的 shared state 仍是有效的，在调用了get()函数之后。  

如果任何成员函数而不是析构函数、move赋值操作符或valid被调用在一个并不指向任何shared state的shared_future之上，行为就是未定义的。  


### 6.4.6 wait 函数  

void wait() const;  

阻塞直到结果可得. 调用之后,valid() == true.  

如果在调用此函数前，valid() == false, 那么行为未定义。  

注意： 
鼓励在调用此函数前，先检查一下valid()是否为false。如果是，那么就抛出一个 std::future_error 异常，带有的错误条件为 std::future_errc::no_state.  
在多线程上对同一个 std::shared_future 调用wait 是不安全的；正确的使用方式是，对每一个线程，都在其对std::shared_future所做的copy上做wait.  

示例程序： 06_04_shared_future_wait.cpp  

### 6.4.7 wait_for函数  

template< class Rep, class Period >  
std::future_status wait_for( const std::chrono::duration<Rep, Period>& timeout_duration ) const;  

等待结果可得。阻塞直到指定的时限 timeout_duration 超时或者结果可得。返回值指明了结果的状态。  

一个steady clock被用来度量经过的时间。这个函数可能会阻塞比timeout_duration更长一些的时间，因为操作系统分配或资源竞争的缘故。  

如果在调用此函数前，valid() == false, 那么行为未定义。  

返回值： 
future_status::deferred    函数的执行还没有开始  
future_status::ready       结果已经可得  
future_status::timeout     已超时  

注意：  
鼓励在调用此函数前，先检查一下valid() == false. 若真如此，就抛出一个future_error异常，带有的错误条件为 future_errc::no_state.  

示例程序： 06_04_shared_future_wait_for.cpp  

### 6.4.8 wait_until 函数 

略 

### 6.4.9  示例程序  

06_04_shared_future.cpp  

## 6.5 std::async

定义在头文件 <future> 中。  

1)  
(since C++11, until C++14)
template< class Function, class... Args >
std::future<typename std::result_of<Function(Args...)>::type> async( Function&& f, Args&&... args );  

(since C++14)
template< class Function, class... Args>
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>> async( Function&& f, Args&&... args );  

2)  
(since C++11, until C++14)
template< class Function, class... Args >
std::future<typename std::result_of<Function(Args...)>::type 
    async( std::launch policy, Function&& f, Args&&... args );  

(since C++14)
template< class Function, class... Args >
std::future<std::result_of_t<std::decay_t<Function>(std::decay_t<Args>...)>> 
    async( std::launch policy, Function&& f, Args&&... args );

模板函数 aync 异步地（以另一个线程来运行，而此线程可能是线程池的一部分）运行函数f，并返回一个std::future对象以最终返回该函数调用的结果。  

1) 表现得如同 async(std::launch::async | std::launch::deferred, f, args...). 换句话说，f可能在另一个线程中被执行，或者是当查询std::future的结果值时f被同步地执行。  

2) 根据指定的launch policy，以args为参数来调用函数f.  

- 如果 async 的标志位被设置（即， policy & std::launch::async != 0），那么async在一个新的线程中执行函数f，就如同被std::thread(f, args...)生成出来一样，除了函数f返回一个值或抛出一个异常，返回值是被存储在shared state中，而该shared state可以通过async所返回的std::future对象来访问。  

- 如果 deferred 标志位被设置（即，policy & std::launch::deferred != 0），那么 async 将args...进行转换，就如同std::thread的构造函数一样，但是不会产生一个新的线程来执行。相反的，懒惰执行会发生，即： 对于std::future的第一个非限时wait函数的调用将会引起 f(args...) 在同一个线程中被执行（该线程不一定是原来调用std::async的线程）。结果值或者异常被放在和future对象相关联的shared state中。 所有将来对std::future的访问都会立即得到结果。  

- 如果 std::launch::async 和 std::launch::deferred 标志位都被设置在policy里面，那究竟是异步执行还是懒惰调用就取决于实现了。  

- since C++14，如果 std::launch::async 和 std::launch::deferred 都没有被设置，则行为未定义。  

无论何种情况，对 std::async 的调用都会与对f的调用同步，而f的完成一定是在使得 shared state 准备好之前发生的。如果选择的是 async policy，那么相关的线程完成 就会与 等待在shared state上的第一个函数的成功返回 或 释放shared state的最后一个函数的返回 同步，具体同步哪个取决于谁先发生。  


### 参数  

f - 所调用的 Callable 对象  
args - 传递给 f 的参数  
policy - 或者是 std::launch::async , 或者是 std::launch::deferred. 前者含义是异步处理，后者含义是“懒惰处理”。  

类型要求：  
对于函数，参数必须满足 MoveConstructible 的要求。  

### 返回值  

std::future, 指向的是被std::async所创建的shared state.  

### 异常  

抛出 std::system_error. 如果 launch policy 是 std::launch::async 并且实现中无法启动一个新的线程，那么该system_error的error condition就是 std::errc::resource_unavailable_try_again.  

### 示例程序  
06_05_async.cpp  

## 6.6 std::launch  

定义在头文件 <future> 中。


enum class launch : /* unspecified */ {
    async = /* unspecified */ ,
    deferred = /* unspecified */,     // since C++11
    /* implementation-defined */
};  

为以std::async方法来执行一个task时，指定装载策略。std::launch是一个用作BitmaskType的枚举类型。 

常量                      解释
std::launch::async        装载一个新的线程来异步地执行任务  
std::launch::deferred     只在第一次要求结果的时候才在所调用的线程中执行该任务（lazy evaluation）  

## 6.7 std::future_status  

定义在头文件 <future> 中。

enum class future_status {
    ready, 
    timeout,      // since C++11   
    deferred  
};  

std::future或std::shared_future的wait_for和wait_until函数会返回一个future，那么该future的状态就是future_status.  

常量                含义
deferred            该shared_state包含一个deferred函数，所以结果只在被显式地要求时才会被计算。  
ready               该shared_state已经ready.  
timeout             在timeout结束之前，该shared_state没有变成ready.  


## 6.7 std::future_error  

定义在头文件 <future> 中。  

class future_error;  // since C++11  

类std::future_error定义了一个exception对象。当处理异步执行和shared states的函数库（如std::future, std::promise,等等）失败的时候会抛出该exception对象。  
与std::system_error类似，该exception携带了一个与std::error_code相兼容的error code.  


## 6.8 std::future_category  

定义在头文件 <future> 中。  
const std::error_category& future_category();    // since C++11  

获得一个对静态错误分类对象（关于futures和promises）的引用。该对象被要求重写（override）虚函数 error_category::name() 以返回一个指向字符串"future"的指针。它被用来标识std::future_error的异常。  


## 6.9 std::future_errc  

定义在头文件 <future> 中。  

enum class future_errc {
    broken_promise            = /* implementation-defined */,  
    future_already_retrieved  = /* implementation-defined */,   // since C++11  
    promise_already_satisfied = /* implementation-defined */,   
    no_state                  = /* implementation-defined */  
};  

有范围限制的枚举类型 std::future_errc 定义了被 std::future 和在std::future_error的异常对象中的相关类所报出的error code. 尽管实现可能定义更多的error code，但只有4种error code被要求。 因为 std::is_error_code_enum 的合适的序列化被提供了，所以std::future_errc的类型的值就会被隐式地转换为 std::error_code.  

常量                          含义  
broken_promise                异步任务禁止它的shared state  
future_already_retrieved      shared state的内容已经通过 std::future 被处理  
promise_already_satisfied     试图向shared state中两次存储一个值  
no_state                      试图访问没有相关联的shared state的std::promise或std::future.  



----------------------------------------------------------------------

# 附录-1 std::terminate

# 附录-2  
- [http://en.cppreference.com/w/cpp/concept/MoveConstructible](http://en.cppreference.com/w/cpp/concept/MoveConstructible)
- [http://en.cppreference.com/w/cpp/concept/MoveAssignable](http://en.cppreference.com/w/cpp/concept/MoveAssignable)

# 附录-3 
- [http://en.cppreference.com/w/cpp/atomic/atomic](http://en.cppreference.com/w/cpp/atomic/atomic)
- [http://en.cppreference.com/w/cpp/language/memory_model](http://en.cppreference.com/w/cpp/language/memory_model)
- [http://en.cppreference.com/w/cpp/atomic/memory_order](http://en.cppreference.com/w/cpp/atomic/memory_order)
- [http://en.cppreference.com/w/cpp/atomic/atomic/fetch_add](http://en.cppreference.com/w/cpp/atomic/atomic/fetch_add)

# 附录-4 C++ Concepts
- [Lockable](http://en.cppreference.com/w/cpp/concept/Lockable)  
- [BasicLockable](http://en.cppreference.com/w/cpp/concept/BasicLockable)
- [TimedLockable](http://en.cppreference.com/w/cpp/concept/TimedLockable)
